@using System.Collections.Generic;
@using System.Linq;
@using System.Text;
@using System;
@using AutoRest.Core.Model
@using AutoRest.Core.Utilities
@using AutoRest.Go
@using AutoRest.Go.Model

@inherits AutoRest.Core.Template<AutoRest.Go.Model.MethodGo>

@{
    StringBuilder sb = new StringBuilder();
    foreach (var parameter in Model.LocalParameters)
    {
        if (!string.IsNullOrEmpty(parameter.Documentation))
        {
            sb.Append(parameter.Name);
            sb.Append(" is ");
            sb.Append(parameter.Documentation.FixedValue.ToSentence());
            sb.Append(" ");
        }
        if (parameter.ModelType.PrimaryType(KnownPrimaryType.Stream))
        {
            sb.Append(parameter.Name);
            sb.Append(" will be closed upon successful return. Callers should ensure closure when receiving an error.");
        }
    }

    List<string> pd = Model.PrepareDecorators;
    List<string> rd = Model.RespondDecorators;
    rd.Insert(0, "resp");
}

@WrapComment("// ", Model.Name + " " + Model.Description.ToSentence())
@if (Model.LocalParameters.Count() > 0)
{
@://
@WrapComment("// ", sb.ToString())
}

func (client @(Model.Owner)) @(Model.MethodSignature) (@Model.MethodReturnSignature) {
    @if (Model.ParameterValidations.Length > 0)
    {
    @:if err := validation.Validate([]validation.Validation{
         @:@(Model.ParameterValidations)}); err != nil {
             @:return result, @(Model.ValidationError)
    @:}
    @:@EmptyLine
    }
    req, err := client.@(Model.PreparerMethodName)(@(Model.HelperInvocationParameters))
    if err != nil {
        return result, @(Model.AutorestError("Failure preparing request"))
    }

    @EmptyLine
    resp, err := client.@(Model.SenderMethodName)(req)
    if err != nil {
        @(Model.Response)
        return result, @(Model.AutorestError("Failure sending request", "resp"))
    }

    @EmptyLine
    result, err = client.@(Model.ResponderMethodName)(resp)
    if err != nil {
        err = @(Model.AutorestError("Failure responding to request", "resp"))
    }

    @EmptyLine
    return
}

@EmptyLine
// @(Model.PreparerMethodName) prepares the @(Model.Name) request.
func (client @(Model.Owner)) @(Model.PreparerMethodName)(@(Model.MethodParametersSignature)) (*http.Request, error) {
@if (Model.IsCustomBaseUri && Model.URLParameters.Any())
{
    @:@(Model.URLMap)
    @:@EmptyLine
}
@if (Model.PathParameters.Any())
{
    @:@(Model.PathMap)
    @:@EmptyLine
}
@if (Model.QueryParameters.Any())
{
    @if (Model.QueryParameters.Any(p => p.GetParameterName().IsApiVersion())) 
    {
        @:@(string.Format("const APIVersion = \"{0}\"", Model.APIVersion))
    }
    @:@(Model.QueryMap)
    foreach (var p in Model.OptionalQueryParameters)
    {
    @:if @(p.ModelType.GetEmptyCheck(p.GetParameterName(),false)) {
        @:@(p.AddToMap("queryParameters"))
    @:}
    }
    @:@EmptyLine
}

@if (Model.FormDataParameters.Any())
{
    @:@(Model.FormDataMap)
    @:@EmptyLine
}


    preparer := autorest.CreatePreparer(
                        @(pd.EmitAsArguments()))

@if (Model.BodyParameter != null && !Model.BodyParameter.IsRequired)
{
    @:if @(Model.BodyParameter.ModelType.GetEmptyCheck(Model.BodyParameter.Name, false)) {
        @:preparer = autorest.DecoratePreparer(preparer,
                            @:@(string.Format("autorest.WithJSON({0})", Model.BodyParameter.Name)))
    @:}
}

@foreach (var p in Model.OptionalHeaderParameters)
    {
    @:if @(p.ModelType.GetEmptyCheck(p.GetParameterName(), false)) {
        @:preparer = autorest.DecoratePreparer(preparer,
                            @:@(string.Format("autorest.WithHeader(\"{0}\",autorest.String({1}))",
                            p.SerializedName, p.GetParameterName())))
    @:}
}

    @(Model.IsLongRunningOperation()
        ? "return preparer.Prepare(&http.Request{Cancel: cancel})"
        : "return preparer.Prepare(&http.Request{})")
}


@EmptyLine
// @(Model.SenderMethodName) sends the @(Model.Name) request. The method will close the
// http.Response Body if it receives an error.
func (client @(Model.Owner)) @(Model.SenderMethodName)(req *http.Request) (*http.Response, error) {
    @if (Model.IsLongRunningOperation())
    {
        @:return autorest.SendWithSender(client,
                                                    @:req,
                                                    @:azure.DoPollForAsynchronous(client.PollingDelay))
    }
    else
    {
    @:return autorest.SendWithSender(client, req)
    }
}

@EmptyLine
// @(Model.ResponderMethodName) handles the response to the @(Model.Name) request. The method always
// closes the http.Response Body.
func (client @(Model.Owner)) @(Model.ResponderMethodName)(resp *http.Response) (@(Model.MethodReturnSignature)) { 
    @if (Model.ReturnValue().Body.IsStreamType())
    {
    @:result.Value = &resp.Body
    }
    err = autorest.Respond(
            @(rd.EmitAsArguments()))

    @(Model.Response)
    @if (Model.IsPageable)
    {
    @if (Model.Owner == "ManagementClient")
    {
    @:result.client = client
    }
    else
    {
    @:result.client = client.ManagementClient
    }
    }
    return
}

@if (Model.IsPageable && !Model.IsNextMethod)
{
@:@EmptyLine
@:// @(Model.ListCompleteMethodName) gets all elements from the list without paging.
@:func (client @(Model.Owner)) @(Model.ListCompleteMethodName) @(Model.MethodParametersSignatureComplete) @(Model.MethodReturnSignatureComplete) {
    @:respSlice := @((Model.ListElement.ModelType as SequenceTypeGo).Name){}
    @:list, err := client.@(Model.Name)(@(Model.HelperInvocationParameters))
    @:if err != nil {
        @:return respSlice, err
    @:}
    @:if list.@(Model.ListElement.Name) != nil {
        @:for _, item := range *list.@(Model.ListElement.Name) {
            @:respSlice = append(respSlice, item)
        @:}
    @:}
    @:for list.@(Model.NextLink()) != nil {
        @:select {
        @:case <- cancel:
            @:return respSlice, nil
        @:default:
            if (!Model.NextAlreadyDefined)
            {
            @:list, err = list.Next()
            }
            else
            {
            @:list, err = client.@(Model.NextOperationName)(@(Model.NextOperationParameters))
            }
            @:if err != nil {
                @:return respSlice, err
            @:}            
            @:if list.@(Model.ListElement.Name) != nil {
                @:for _, item := range *list.@(Model.ListElement.Name) {
                    @:respSlice = append(respSlice, item)
                @:}
            @:}
        @:}
    @:}
    @:return respSlice, err
@:}
}
