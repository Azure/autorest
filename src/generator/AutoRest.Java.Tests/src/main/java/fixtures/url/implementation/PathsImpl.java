/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url.implementation;

import retrofit2.Retrofit;
import fixtures.url.Paths;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.Base64Url;
import com.microsoft.rest.serializer.CollectionFormat;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.Validator;
import fixtures.url.models.ErrorException;
import fixtures.url.models.UriColor;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.apache.commons.codec.binary.Base64;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Paths.
 */
public final class PathsImpl implements Paths {
    /** The Retrofit service to perform REST calls. */
    private PathsService service;
    /** The service client containing this operation class. */
    private AutoRestUrlTestServiceImpl client;

    /**
     * Initializes an instance of Paths.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public PathsImpl(Retrofit retrofit, AutoRestUrlTestServiceImpl client) {
        this.service = retrofit.create(PathsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Paths to be
     * used by Retrofit to perform actually REST calls.
     */
    interface PathsService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/bool/true/{boolPath}")
        Observable<Response<ResponseBody>> getBooleanTrue(@Path("boolPath") boolean boolPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/bool/false/{boolPath}")
        Observable<Response<ResponseBody>> getBooleanFalse(@Path("boolPath") boolean boolPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/int/1000000/{intPath}")
        Observable<Response<ResponseBody>> getIntOneMillion(@Path("intPath") int intPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/int/-1000000/{intPath}")
        Observable<Response<ResponseBody>> getIntNegativeOneMillion(@Path("intPath") int intPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/long/10000000000/{longPath}")
        Observable<Response<ResponseBody>> getTenBillion(@Path("longPath") long longPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/long/-10000000000/{longPath}")
        Observable<Response<ResponseBody>> getNegativeTenBillion(@Path("longPath") long longPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/float/1.034E+20/{floatPath}")
        Observable<Response<ResponseBody>> floatScientificPositive(@Path("floatPath") double floatPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/float/-1.034E-20/{floatPath}")
        Observable<Response<ResponseBody>> floatScientificNegative(@Path("floatPath") double floatPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/double/9999999.999/{doublePath}")
        Observable<Response<ResponseBody>> doubleDecimalPositive(@Path("doublePath") double doublePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/double/-9999999.999/{doublePath}")
        Observable<Response<ResponseBody>> doubleDecimalNegative(@Path("doublePath") double doublePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/unicode/{stringPath}")
        Observable<Response<ResponseBody>> stringUnicode(@Path("stringPath") String stringPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend/{stringPath}")
        Observable<Response<ResponseBody>> stringUrlEncoded(@Path("stringPath") String stringPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/empty/{stringPath}")
        Observable<Response<ResponseBody>> stringEmpty(@Path("stringPath") String stringPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/null/{stringPath}")
        Observable<Response<ResponseBody>> stringNull(@Path("stringPath") String stringPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/enum/green%20color/{enumPath}")
        Observable<Response<ResponseBody>> enumValid(@Path("enumPath") UriColor enumPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/null/{enumPath}")
        Observable<Response<ResponseBody>> enumNull(@Path("enumPath") UriColor enumPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/byte/multibyte/{bytePath}")
        Observable<Response<ResponseBody>> byteMultiByte(@Path("bytePath") String bytePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/byte/empty/{bytePath}")
        Observable<Response<ResponseBody>> byteEmpty(@Path("bytePath") String bytePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/byte/null/{bytePath}")
        Observable<Response<ResponseBody>> byteNull(@Path("bytePath") String bytePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/date/2012-01-01/{datePath}")
        Observable<Response<ResponseBody>> dateValid(@Path("datePath") LocalDate datePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/date/null/{datePath}")
        Observable<Response<ResponseBody>> dateNull(@Path("datePath") LocalDate datePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/datetime/2012-01-01T01%3A01%3A01Z/{dateTimePath}")
        Observable<Response<ResponseBody>> dateTimeValid(@Path("dateTimePath") DateTime dateTimePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/datetime/null/{dateTimePath}")
        Observable<Response<ResponseBody>> dateTimeNull(@Path("dateTimePath") DateTime dateTimePath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/string/bG9yZW0/{base64UrlPath}")
        Observable<Response<ResponseBody>> base64Url(@Path("base64UrlPath") Base64Url base64UrlPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/array/ArrayPath1%2cbegin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend%2c%2c/{arrayPath:commaSeparated}")
        Observable<Response<ResponseBody>> arrayCsvInPath(@Path("arrayPath") String arrayPath);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("paths/int/1460505600/{unixTimeUrlPath}")
        Observable<Response<ResponseBody>> unixTimeUrl(@Path("unixTimeUrlPath") long unixTimeUrlPath);

    }

    /**
     * Get true Boolean value on path.
     *
     */
    public void getBooleanTrue() {
        getBooleanTrueWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get true Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanTrueAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanTrueWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanTrueAsync() {
        return getBooleanTrueWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get true Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanTrueWithServiceResponseAsync() {
        final boolean boolPath = true;
        return service.getBooleanTrue(boolPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanTrueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getBooleanTrueDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get false Boolean value on path.
     *
     */
    public void getBooleanFalse() {
        getBooleanFalseWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get false Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanFalseAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanFalseWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanFalseAsync() {
        return getBooleanFalseWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get false Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanFalseWithServiceResponseAsync() {
        final boolean boolPath = false;
        return service.getBooleanFalse(boolPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanFalseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getBooleanFalseDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '1000000' integer value.
     *
     */
    public void getIntOneMillion() {
        getIntOneMillionWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntOneMillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntOneMillionWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntOneMillionAsync() {
        return getIntOneMillionWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntOneMillionWithServiceResponseAsync() {
        final int intPath = 1000000;
        return service.getIntOneMillion(intPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntOneMillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIntOneMillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-1000000' integer value.
     *
     */
    public void getIntNegativeOneMillion() {
        getIntNegativeOneMillionWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntNegativeOneMillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntNegativeOneMillionWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntNegativeOneMillionAsync() {
        return getIntNegativeOneMillionWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntNegativeOneMillionWithServiceResponseAsync() {
        final int intPath = -1000000;
        return service.getIntNegativeOneMillion(intPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntNegativeOneMillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIntNegativeOneMillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     */
    public void getTenBillion() {
        getTenBillionWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getTenBillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getTenBillionWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getTenBillionAsync() {
        return getTenBillionWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getTenBillionWithServiceResponseAsync() {
        final long longPath = 10000000000L;
        return service.getTenBillion(longPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getTenBillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getTenBillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     */
    public void getNegativeTenBillion() {
        getNegativeTenBillionWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getNegativeTenBillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getNegativeTenBillionWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getNegativeTenBillionAsync() {
        return getNegativeTenBillionWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getNegativeTenBillionWithServiceResponseAsync() {
        final long longPath = -10000000000L;
        return service.getNegativeTenBillion(longPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getNegativeTenBillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getNegativeTenBillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     */
    public void floatScientificPositive() {
        floatScientificPositiveWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatScientificPositiveAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatScientificPositiveWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatScientificPositiveAsync() {
        return floatScientificPositiveWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatScientificPositiveWithServiceResponseAsync() {
        final double floatPath = 1.034E+20;
        return service.floatScientificPositive(floatPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatScientificPositiveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> floatScientificPositiveDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     */
    public void floatScientificNegative() {
        floatScientificNegativeWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatScientificNegativeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatScientificNegativeWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatScientificNegativeAsync() {
        return floatScientificNegativeWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatScientificNegativeWithServiceResponseAsync() {
        final double floatPath = -1.034E-20;
        return service.floatScientificNegative(floatPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatScientificNegativeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> floatScientificNegativeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     */
    public void doubleDecimalPositive() {
        doubleDecimalPositiveWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleDecimalPositiveAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleDecimalPositiveWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleDecimalPositiveAsync() {
        return doubleDecimalPositiveWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleDecimalPositiveWithServiceResponseAsync() {
        final double doublePath = 9999999.999;
        return service.doubleDecimalPositive(doublePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleDecimalPositiveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> doubleDecimalPositiveDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     */
    public void doubleDecimalNegative() {
        doubleDecimalNegativeWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleDecimalNegativeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleDecimalNegativeWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleDecimalNegativeAsync() {
        return doubleDecimalNegativeWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleDecimalNegativeWithServiceResponseAsync() {
        final double doublePath = -9999999.999;
        return service.doubleDecimalNegative(doublePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleDecimalNegativeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> doubleDecimalNegativeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     */
    public void stringUnicode() {
        stringUnicodeWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringUnicodeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringUnicodeWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringUnicodeAsync() {
        return stringUnicodeWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringUnicodeWithServiceResponseAsync() {
        final String stringPath = "啊齄丂狛狜隣郎隣兀﨩";
        return service.stringUnicode(stringPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringUnicodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringUnicodeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     */
    public void stringUrlEncoded() {
        stringUrlEncodedWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringUrlEncodedAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringUrlEncodedWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringUrlEncodedAsync() {
        return stringUrlEncodedWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringUrlEncodedWithServiceResponseAsync() {
        final String stringPath = "begin!*'();:@ &=+$,/?#[]end";
        return service.stringUrlEncoded(stringPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringUrlEncodedDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringUrlEncodedDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get ''.
     *
     */
    public void stringEmpty() {
        stringEmptyWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get ''.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringEmptyAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get ''.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringEmptyAsync() {
        return stringEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get ''.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringEmptyWithServiceResponseAsync() {
        final String stringPath = "";
        return service.stringEmpty(stringPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value
     */
    public void stringNull(String stringPath) {
        stringNullWithServiceResponseAsync(stringPath).toBlocking().single().getBody();
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringNullAsync(String stringPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringNullWithServiceResponseAsync(stringPath), serviceCallback);
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringNullAsync(String stringPath) {
        return stringNullWithServiceResponseAsync(stringPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringNullWithServiceResponseAsync(String stringPath) {
        if (stringPath == null) {
            throw new IllegalArgumentException("Parameter stringPath is required and cannot be null.");
        }
        return service.stringNull(stringPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'
     */
    public void enumValid(UriColor enumPath) {
        enumValidWithServiceResponseAsync(enumPath).toBlocking().single().getBody();
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumValidAsync(UriColor enumPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumValidWithServiceResponseAsync(enumPath), serviceCallback);
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumValidAsync(UriColor enumPath) {
        return enumValidWithServiceResponseAsync(enumPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumValidWithServiceResponseAsync(UriColor enumPath) {
        if (enumPath == null) {
            throw new IllegalArgumentException("Parameter enumPath is required and cannot be null.");
        }
        return service.enumValid(enumPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enumValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'
     */
    public void enumNull(UriColor enumPath) {
        enumNullWithServiceResponseAsync(enumPath).toBlocking().single().getBody();
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumNullAsync(UriColor enumPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumNullWithServiceResponseAsync(enumPath), serviceCallback);
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumNullAsync(UriColor enumPath) {
        return enumNullWithServiceResponseAsync(enumPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumNullWithServiceResponseAsync(UriColor enumPath) {
        if (enumPath == null) {
            throw new IllegalArgumentException("Parameter enumPath is required and cannot be null.");
        }
        return service.enumNull(enumPath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enumNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     */
    public void byteMultiByte(byte[] bytePath) {
        byteMultiByteWithServiceResponseAsync(bytePath).toBlocking().single().getBody();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteMultiByteAsync(byte[] bytePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteMultiByteWithServiceResponseAsync(bytePath), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteMultiByteAsync(byte[] bytePath) {
        return byteMultiByteWithServiceResponseAsync(bytePath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteMultiByteWithServiceResponseAsync(byte[] bytePath) {
        if (bytePath == null) {
            throw new IllegalArgumentException("Parameter bytePath is required and cannot be null.");
        }
        String bytePathConverted = Base64.encodeBase64String(bytePath);
        return service.byteMultiByte(bytePathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteMultiByteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteMultiByteDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '' as byte array.
     *
     */
    public void byteEmpty() {
        byteEmptyWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '' as byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteEmptyAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '' as byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteEmptyAsync() {
        return byteEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '' as byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteEmptyWithServiceResponseAsync() {
        final byte[] bytePath = "".getBytes();
        String bytePathConverted = Base64.encodeBase64String(bytePath);
        return service.byteEmpty(bytePathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw)
     */
    public void byteNull(byte[] bytePath) {
        byteNullWithServiceResponseAsync(bytePath).toBlocking().single().getBody();
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteNullAsync(byte[] bytePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteNullWithServiceResponseAsync(bytePath), serviceCallback);
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteNullAsync(byte[] bytePath) {
        return byteNullWithServiceResponseAsync(bytePath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteNullWithServiceResponseAsync(byte[] bytePath) {
        if (bytePath == null) {
            throw new IllegalArgumentException("Parameter bytePath is required and cannot be null.");
        }
        String bytePathConverted = Base64.encodeBase64String(bytePath);
        return service.byteNull(bytePathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '2012-01-01' as date.
     *
     */
    public void dateValid() {
        dateValidWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateValidAsync() {
        return dateValidWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateValidWithServiceResponseAsync() {
        final LocalDate datePath = LocalDate.parse("2012-01-01");
        return service.dateValid(datePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw)
     */
    public void dateNull(LocalDate datePath) {
        dateNullWithServiceResponseAsync(datePath).toBlocking().single().getBody();
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateNullAsync(LocalDate datePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateNullWithServiceResponseAsync(datePath), serviceCallback);
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateNullAsync(LocalDate datePath) {
        return dateNullWithServiceResponseAsync(datePath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateNullWithServiceResponseAsync(LocalDate datePath) {
        if (datePath == null) {
            throw new IllegalArgumentException("Parameter datePath is required and cannot be null.");
        }
        return service.dateNull(datePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     */
    public void dateTimeValid() {
        dateTimeValidWithServiceResponseAsync().toBlocking().single().getBody();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateTimeValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateTimeValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateTimeValidAsync() {
        return dateTimeValidWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateTimeValidWithServiceResponseAsync() {
        final DateTime dateTimePath = DateTime.parse("2012-01-01T01:01:01Z");
        return service.dateTimeValid(dateTimePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time
     */
    public void dateTimeNull(DateTime dateTimePath) {
        dateTimeNullWithServiceResponseAsync(dateTimePath).toBlocking().single().getBody();
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateTimeNullAsync(DateTime dateTimePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateTimeNullWithServiceResponseAsync(dateTimePath), serviceCallback);
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateTimeNullAsync(DateTime dateTimePath) {
        return dateTimeNullWithServiceResponseAsync(dateTimePath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateTimeNullWithServiceResponseAsync(DateTime dateTimePath) {
        if (dateTimePath == null) {
            throw new IllegalArgumentException("Parameter dateTimePath is required and cannot be null.");
        }
        return service.dateTimeNull(dateTimePath)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateTimeNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateTimeNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value
     */
    public void base64Url(byte[] base64UrlPath) {
        base64UrlWithServiceResponseAsync(base64UrlPath).toBlocking().single().getBody();
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> base64UrlAsync(byte[] base64UrlPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(base64UrlWithServiceResponseAsync(base64UrlPath), serviceCallback);
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> base64UrlAsync(byte[] base64UrlPath) {
        return base64UrlWithServiceResponseAsync(base64UrlPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> base64UrlWithServiceResponseAsync(byte[] base64UrlPath) {
        if (base64UrlPath == null) {
            throw new IllegalArgumentException("Parameter base64UrlPath is required and cannot be null.");
        }
        Base64Url base64UrlPathConverted = Base64Url.encode(base64UrlPath);
        return service.base64Url(base64UrlPathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = base64UrlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> base64UrlDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     */
    public void arrayCsvInPath(List<String> arrayPath) {
        arrayCsvInPathWithServiceResponseAsync(arrayPath).toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayCsvInPathAsync(List<String> arrayPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayCsvInPathWithServiceResponseAsync(arrayPath), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayCsvInPathAsync(List<String> arrayPath) {
        return arrayCsvInPathWithServiceResponseAsync(arrayPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayCsvInPathWithServiceResponseAsync(List<String> arrayPath) {
        if (arrayPath == null) {
            throw new IllegalArgumentException("Parameter arrayPath is required and cannot be null.");
        }
        Validator.validate(arrayPath);
        String arrayPathConverted = this.client.mapperAdapter().serializeList(arrayPath, CollectionFormat.CSV);
        return service.arrayCsvInPath(arrayPathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayCsvInPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayCsvInPathDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value
     */
    public void unixTimeUrl(DateTime unixTimeUrlPath) {
        unixTimeUrlWithServiceResponseAsync(unixTimeUrlPath).toBlocking().single().getBody();
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> unixTimeUrlAsync(DateTime unixTimeUrlPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(unixTimeUrlWithServiceResponseAsync(unixTimeUrlPath), serviceCallback);
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unixTimeUrlAsync(DateTime unixTimeUrlPath) {
        return unixTimeUrlWithServiceResponseAsync(unixTimeUrlPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unixTimeUrlWithServiceResponseAsync(DateTime unixTimeUrlPath) {
        Long unixTimeUrlPathConverted = unixTimeUrlPath.toDateTime(DateTimeZone.UTC).getMillis() / 1000;
        return service.unixTimeUrl(unixTimeUrlPathConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unixTimeUrlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> unixTimeUrlDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
