/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.lro;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import fixtures.lro.models.Product;
import fixtures.lro.models.CloudError;

public class LROSADsImpl implements LROSADs {
    private LROSADsService service;
    AutoRestLongRunningOperationTestService client;

    public LROSADsImpl(RestAdapter restAdapter, AutoRestLongRunningOperationTestService client) {
        this.service = restAdapter.create(LROSADsService.class);
        this.client = client;
    }

    /**
     * Long running put request, service returns a 400 to the initial request
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putNonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putNonRetry400Delegate(service.putNonRetry400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putNonRetry400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 400 to the initial request
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putNonRetry400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putNonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 400 to the initial request
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutNonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutNonRetry400Delegate(service.beginPutNonRetry400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutNonRetry400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 400 to the initial request
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutNonRetry400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutNonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a Product with
     * 'ProvisioningState' = 'Creating' and 201 response code
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putNonRetry201Creating400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putNonRetry201Creating400Delegate(service.putNonRetry201Creating400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putNonRetry201Creating400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a Product with
     * 'ProvisioningState' = 'Creating' and 201 response code
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putNonRetry201Creating400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putNonRetry201Creating400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putNonRetry201Creating400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putNonRetry201Creating400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a Product with
     * 'ProvisioningState' = 'Creating' and 201 response code
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutNonRetry201Creating400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutNonRetry201Creating400Delegate(service.beginPutNonRetry201Creating400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutNonRetry201Creating400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a Product with
     * 'ProvisioningState' = 'Creating' and 201 response code
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutNonRetry201Creating400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutNonRetry201Creating400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutNonRetry201Creating400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutNonRetry201Creating400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 with
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRelativeRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRelativeRetry400Delegate(service.putAsyncRelativeRetry400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRelativeRetry400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 with
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRelativeRetry400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRelativeRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 with
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRelativeRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetry400Delegate(service.beginPutAsyncRelativeRetry400(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetry400Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 with
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRelativeRetry400Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRelativeRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 400 with an error body
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteNonRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteNonRetry400Delegate(service.deleteNonRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteNonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 400 with an error body
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteNonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.deleteNonRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 400 with an error body
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteNonRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteNonRetry400Delegate(service.beginDeleteNonRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteNonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 400 with an error body
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteNonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteNonRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 with a location
     * header
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void delete202NonRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = delete202NonRetry400Delegate(service.delete202NonRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = delete202NonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 with a location
     * header
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete202NonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.delete202NonRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete202NonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> delete202NonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 with a location
     * header
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDelete202NonRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDelete202NonRetry400Delegate(service.beginDelete202NonRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDelete202NonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 with a location
     * header
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete202NonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.beginDelete202NonRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete202NonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDelete202NonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRelativeRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRelativeRetry400Delegate(service.deleteAsyncRelativeRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRelativeRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRelativeRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRelativeRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRelativeRetry400() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetry400Delegate(service.beginDeleteAsyncRelativeRetry400(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRelativeRetry400Async(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRelativeRetry400Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 400 with no error body
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postNonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postNonRetry400Delegate(service.postNonRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postNonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 400 with no error body
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postNonRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postNonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 400 with no error body
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostNonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostNonRetry400Delegate(service.beginPostNonRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostNonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 400 with no error body
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostNonRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostNonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostNonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostNonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 with a location header
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void post202NonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = post202NonRetry400Delegate(service.post202NonRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = post202NonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 with a location header
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post202NonRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.post202NonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post202NonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> post202NonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 with a location header
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPost202NonRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPost202NonRetry400Delegate(service.beginPost202NonRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPost202NonRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 with a location header
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost202NonRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPost202NonRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost202NonRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPost202NonRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRelativeRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRelativeRetry400Delegate(service.postAsyncRelativeRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRelativeRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRelativeRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRelativeRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRelativeRetry400(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetry400Delegate(service.beginPostAsyncRelativeRetry400(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetry400Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRelativeRetry400Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRelativeRetry400Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRelativeRetry400Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRelativeRetry400Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request
     * with no payload
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putError201NoProvisioningStatePayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putError201NoProvisioningStatePayloadDelegate(service.putError201NoProvisioningStatePayload(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putError201NoProvisioningStatePayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request
     * with no payload
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putError201NoProvisioningStatePayloadAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putError201NoProvisioningStatePayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putError201NoProvisioningStatePayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putError201NoProvisioningStatePayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request
     * with no payload
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutError201NoProvisioningStatePayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutError201NoProvisioningStatePayloadDelegate(service.beginPutError201NoProvisioningStatePayload(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutError201NoProvisioningStatePayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request
     * with no payload
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutError201NoProvisioningStatePayloadAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutError201NoProvisioningStatePayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutError201NoProvisioningStatePayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutError201NoProvisioningStatePayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRelativeRetryNoStatus(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRelativeRetryNoStatusDelegate(service.putAsyncRelativeRetryNoStatus(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRelativeRetryNoStatusDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRelativeRetryNoStatusAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRelativeRetryNoStatusAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRelativeRetryNoStatusDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRelativeRetryNoStatusDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRelativeRetryNoStatus(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryNoStatusDelegate(service.beginPutAsyncRelativeRetryNoStatus(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryNoStatusDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRelativeRetryNoStatusAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRelativeRetryNoStatusAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRelativeRetryNoStatusDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRelativeRetryNoStatusDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRelativeRetryNoStatusPayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRelativeRetryNoStatusPayloadDelegate(service.putAsyncRelativeRetryNoStatusPayload(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRelativeRetryNoStatusPayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRelativeRetryNoStatusPayloadAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRelativeRetryNoStatusPayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRelativeRetryNoStatusPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRelativeRetryNoStatusPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRelativeRetryNoStatusPayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryNoStatusPayloadDelegate(service.beginPutAsyncRelativeRetryNoStatusPayload(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryNoStatusPayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRelativeRetryNoStatusPayloadAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRelativeRetryNoStatusPayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRelativeRetryNoStatusPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRelativeRetryNoStatusPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 204 to the initial
     * request, indicating success.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void delete204Succeeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = delete204SucceededDelegate(service.delete204Succeeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = delete204SucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 204 to the initial
     * request, indicating success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.delete204SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete204SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> delete204SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 204 to the initial
     * request, indicating success.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDelete204Succeeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDelete204SucceededDelegate(service.beginDelete204Succeeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDelete204SucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 204 to the initial
     * request, indicating success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDelete204SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete204SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDelete204SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRelativeRetryNoStatus() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryNoStatusDelegate(service.deleteAsyncRelativeRetryNoStatus(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryNoStatusDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRelativeRetryNoStatusAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRelativeRetryNoStatusAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRelativeRetryNoStatusDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRelativeRetryNoStatusDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRelativeRetryNoStatus() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryNoStatusDelegate(service.beginDeleteAsyncRelativeRetryNoStatus(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryNoStatusDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRelativeRetryNoStatusAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRelativeRetryNoStatusAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRelativeRetryNoStatusDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRelativeRetryNoStatusDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, without a location header.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void post202NoLocation(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = post202NoLocationDelegate(service.post202NoLocation(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = post202NoLocationDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, without a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post202NoLocationAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.post202NoLocationAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post202NoLocationDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> post202NoLocationDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, without a location header.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPost202NoLocation(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPost202NoLocationDelegate(service.beginPost202NoLocation(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPost202NoLocationDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, without a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost202NoLocationAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPost202NoLocationAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost202NoLocationDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPost202NoLocationDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRelativeRetryNoPayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRelativeRetryNoPayloadDelegate(service.postAsyncRelativeRetryNoPayload(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRelativeRetryNoPayloadDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRelativeRetryNoPayloadAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRelativeRetryNoPayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRelativeRetryNoPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRelativeRetryNoPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRelativeRetryNoPayload(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryNoPayloadDelegate(service.beginPostAsyncRelativeRetryNoPayload(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryNoPayloadDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRelativeRetryNoPayloadAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRelativeRetryNoPayloadAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRelativeRetryNoPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRelativeRetryNoPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that is not a valid json
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put200InvalidJson(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put200InvalidJsonDelegate(service.put200InvalidJson(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put200InvalidJsonDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that is not a valid json
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put200InvalidJsonAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put200InvalidJsonAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put200InvalidJsonDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put200InvalidJsonDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that is not a valid json
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut200InvalidJson(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut200InvalidJsonDelegate(service.beginPut200InvalidJson(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut200InvalidJsonDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that is not a valid json
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut200InvalidJsonAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut200InvalidJsonAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut200InvalidJsonDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut200InvalidJsonDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. The
     * endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRelativeRetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRelativeRetryInvalidHeaderDelegate(service.putAsyncRelativeRetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. The
     * endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRelativeRetryInvalidHeaderAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRelativeRetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. The
     * endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRelativeRetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryInvalidHeaderDelegate(service.beginPutAsyncRelativeRetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. The
     * endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRelativeRetryInvalidHeaderAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRelativeRetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRelativeRetryInvalidJsonPolling(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRelativeRetryInvalidJsonPollingDelegate(service.putAsyncRelativeRetryInvalidJsonPolling(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRelativeRetryInvalidJsonPollingAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRelativeRetryInvalidJsonPollingAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRelativeRetryInvalidJsonPolling(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryInvalidJsonPollingDelegate(service.beginPutAsyncRelativeRetryInvalidJsonPolling(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request,
     * with an entity that contains ProvisioningState=’Creating’. Poll the
     * endpoint indicated in the Azure-AsyncOperation header for operation
     * status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRelativeRetryInvalidJsonPollingAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRelativeRetryInvalidJsonPollingAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request receing a reponse with an invalid 'Location' and 'Retry-After'
     * headers
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void delete202RetryInvalidHeader() throws ServiceException {
        try {
            ServiceResponse<Void> response = delete202RetryInvalidHeaderDelegate(service.delete202RetryInvalidHeader(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = delete202RetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request receing a reponse with an invalid 'Location' and 'Retry-After'
     * headers
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete202RetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        service.delete202RetryInvalidHeaderAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete202RetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> delete202RetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request receing a reponse with an invalid 'Location' and 'Retry-After'
     * headers
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDelete202RetryInvalidHeader() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDelete202RetryInvalidHeaderDelegate(service.beginDelete202RetryInvalidHeader(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDelete202RetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request receing a reponse with an invalid 'Location' and 'Retry-After'
     * headers
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete202RetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDelete202RetryInvalidHeaderAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete202RetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDelete202RetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. The endpoint indicated in the Azure-AsyncOperation header is
     * invalid
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRelativeRetryInvalidHeader() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryInvalidHeaderDelegate(service.deleteAsyncRelativeRetryInvalidHeader(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. The endpoint indicated in the Azure-AsyncOperation header is
     * invalid
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRelativeRetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRelativeRetryInvalidHeaderAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. The endpoint indicated in the Azure-AsyncOperation header is
     * invalid
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRelativeRetryInvalidHeader() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryInvalidHeaderDelegate(service.beginDeleteAsyncRelativeRetryInvalidHeader(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. The endpoint indicated in the Azure-AsyncOperation header is
     * invalid
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRelativeRetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRelativeRetryInvalidHeaderAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRelativeRetryInvalidJsonPolling() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryInvalidJsonPollingDelegate(service.deleteAsyncRelativeRetryInvalidJsonPolling(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRelativeRetryInvalidJsonPollingAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRelativeRetryInvalidJsonPollingAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRelativeRetryInvalidJsonPolling() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryInvalidJsonPollingDelegate(service.beginDeleteAsyncRelativeRetryInvalidJsonPolling(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial
     * request. Poll the endpoint indicated in the Azure-AsyncOperation
     * header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void post202RetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = post202RetryInvalidHeaderDelegate(service.post202RetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = post202RetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post202RetryInvalidHeaderAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.post202RetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post202RetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> post202RetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPost202RetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPost202RetryInvalidHeaderDelegate(service.beginPost202RetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPost202RetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost202RetryInvalidHeaderAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPost202RetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost202RetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPost202RetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRelativeRetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRelativeRetryInvalidHeaderDelegate(service.postAsyncRelativeRetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRelativeRetryInvalidHeaderAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRelativeRetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRelativeRetryInvalidHeader(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryInvalidHeaderDelegate(service.beginPostAsyncRelativeRetryInvalidHeader(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryInvalidHeaderDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRelativeRetryInvalidHeaderAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRelativeRetryInvalidHeaderAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRelativeRetryInvalidHeaderDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRelativeRetryInvalidHeaderDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRelativeRetryInvalidJsonPolling(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRelativeRetryInvalidJsonPollingDelegate(service.postAsyncRelativeRetryInvalidJsonPolling(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRelativeRetryInvalidJsonPollingAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRelativeRetryInvalidJsonPollingAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRelativeRetryInvalidJsonPolling(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryInvalidJsonPollingDelegate(service.beginPostAsyncRelativeRetryInvalidJsonPolling(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRelativeRetryInvalidJsonPollingDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial
     * request, with an entity that contains ProvisioningState=’Creating’.
     * Poll the endpoint indicated in the Azure-AsyncOperation header for
     * operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRelativeRetryInvalidJsonPollingAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRelativeRetryInvalidJsonPollingAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRelativeRetryInvalidJsonPollingDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRelativeRetryInvalidJsonPollingDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

}
