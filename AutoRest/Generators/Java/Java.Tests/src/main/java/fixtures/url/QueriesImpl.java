/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import fixtures.url.models.UriColor;
import org.joda.time.LocalDate;
import org.joda.time.DateTime;
import java.util.List;
import fixtures.url.models.Error;
import org.apache.commons.codec.binary.Base64;
import com.microsoft.rest.serializer.JacksonHelper;
import com.microsoft.rest.serializer.CollectionFormat;

public class QueriesImpl implements Queries {
    private QueriesService service;
    AutoRestUrlTestService client;

    public QueriesImpl(RestAdapter restAdapter, AutoRestUrlTestService client) {
        this.service = restAdapter.create(QueriesService.class);
        this.client = client;
    }

    /**
     * Get true Boolean value on path
     *
     * @param boolQuery true boolean value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getBooleanTrue(Boolean boolQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getBooleanTrueDelegate(service.getBooleanTrue(boolQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getBooleanTrueDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get true Boolean value on path
     *
     * @param boolQuery true boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanTrueAsync(Boolean boolQuery, final ServiceCallback<Void> serviceCallback) {
        service.getBooleanTrueAsync(boolQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanTrueDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getBooleanTrueDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get false Boolean value on path
     *
     * @param boolQuery false boolean value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getBooleanFalse(Boolean boolQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getBooleanFalseDelegate(service.getBooleanFalse(boolQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getBooleanFalseDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get false Boolean value on path
     *
     * @param boolQuery false boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanFalseAsync(Boolean boolQuery, final ServiceCallback<Void> serviceCallback) {
        service.getBooleanFalseAsync(boolQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanFalseDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getBooleanFalseDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null Boolean value on query (query string should be absent)
     *
     * @param boolQuery null boolean value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getBooleanNull(Boolean boolQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getBooleanNullDelegate(service.getBooleanNull(boolQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getBooleanNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null Boolean value on query (query string should be absent)
     *
     * @param boolQuery null boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanNullAsync(Boolean boolQuery, final ServiceCallback<Void> serviceCallback) {
        service.getBooleanNullAsync(boolQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getBooleanNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '1000000' integer value
     *
     * @param intQuery '1000000' integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getIntOneMillion(Integer intQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getIntOneMillionDelegate(service.getIntOneMillion(intQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getIntOneMillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '1000000' integer value
     *
     * @param intQuery '1000000' integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntOneMillionAsync(Integer intQuery, final ServiceCallback<Void> serviceCallback) {
        service.getIntOneMillionAsync(intQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntOneMillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getIntOneMillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-1000000' integer value
     *
     * @param intQuery '-1000000' integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getIntNegativeOneMillion(Integer intQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getIntNegativeOneMillionDelegate(service.getIntNegativeOneMillion(intQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getIntNegativeOneMillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-1000000' integer value
     *
     * @param intQuery '-1000000' integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntNegativeOneMillionAsync(Integer intQuery, final ServiceCallback<Void> serviceCallback) {
        service.getIntNegativeOneMillionAsync(intQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntNegativeOneMillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getIntNegativeOneMillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null integer value (no query parameter)
     *
     * @param intQuery null integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getIntNull(Integer intQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getIntNullDelegate(service.getIntNull(intQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getIntNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null integer value (no query parameter)
     *
     * @param intQuery null integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntNullAsync(Integer intQuery, final ServiceCallback<Void> serviceCallback) {
        service.getIntNullAsync(intQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getIntNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '10000000000' 64 bit integer value
     *
     * @param longQuery '10000000000' 64 bit integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getTenBillion(Long longQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getTenBillionDelegate(service.getTenBillion(longQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getTenBillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '10000000000' 64 bit integer value
     *
     * @param longQuery '10000000000' 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getTenBillionAsync(Long longQuery, final ServiceCallback<Void> serviceCallback) {
        service.getTenBillionAsync(longQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getTenBillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getTenBillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-10000000000' 64 bit integer value
     *
     * @param longQuery '-10000000000' 64 bit integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getNegativeTenBillion(Long longQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getNegativeTenBillionDelegate(service.getNegativeTenBillion(longQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getNegativeTenBillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-10000000000' 64 bit integer value
     *
     * @param longQuery '-10000000000' 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getNegativeTenBillionAsync(Long longQuery, final ServiceCallback<Void> serviceCallback) {
        service.getNegativeTenBillionAsync(longQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getNegativeTenBillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getNegativeTenBillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri)
     *
     * @param longQuery null 64 bit integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getLongNull(Long longQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = getLongNullDelegate(service.getLongNull(longQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getLongNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri)
     *
     * @param longQuery null 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getLongNullAsync(Long longQuery, final ServiceCallback<Void> serviceCallback) {
        service.getLongNullAsync(longQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getLongNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getLongNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '1.034E+20' numeric value
     *
     * @param floatQuery '1.034E+20'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void floatScientificPositive(Double floatQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = floatScientificPositiveDelegate(service.floatScientificPositive(floatQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = floatScientificPositiveDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '1.034E+20' numeric value
     *
     * @param floatQuery '1.034E+20'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void floatScientificPositiveAsync(Double floatQuery, final ServiceCallback<Void> serviceCallback) {
        service.floatScientificPositiveAsync(floatQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(floatScientificPositiveDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> floatScientificPositiveDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-1.034E-20' numeric value
     *
     * @param floatQuery '-1.034E-20'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void floatScientificNegative(Double floatQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = floatScientificNegativeDelegate(service.floatScientificNegative(floatQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = floatScientificNegativeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-1.034E-20' numeric value
     *
     * @param floatQuery '-1.034E-20'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void floatScientificNegativeAsync(Double floatQuery, final ServiceCallback<Void> serviceCallback) {
        service.floatScientificNegativeAsync(floatQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(floatScientificNegativeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> floatScientificNegativeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null numeric value (no query parameter)
     *
     * @param floatQuery null numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void floatNull(Double floatQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = floatNullDelegate(service.floatNull(floatQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = floatNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null numeric value (no query parameter)
     *
     * @param floatQuery null numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void floatNullAsync(Double floatQuery, final ServiceCallback<Void> serviceCallback) {
        service.floatNullAsync(floatQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(floatNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> floatNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '9999999.999' numeric value
     *
     * @param doubleQuery '9999999.999'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void doubleDecimalPositive(Double doubleQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = doubleDecimalPositiveDelegate(service.doubleDecimalPositive(doubleQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = doubleDecimalPositiveDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '9999999.999' numeric value
     *
     * @param doubleQuery '9999999.999'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void doubleDecimalPositiveAsync(Double doubleQuery, final ServiceCallback<Void> serviceCallback) {
        service.doubleDecimalPositiveAsync(doubleQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(doubleDecimalPositiveDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> doubleDecimalPositiveDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-9999999.999' numeric value
     *
     * @param doubleQuery '-9999999.999'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void doubleDecimalNegative(Double doubleQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = doubleDecimalNegativeDelegate(service.doubleDecimalNegative(doubleQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = doubleDecimalNegativeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-9999999.999' numeric value
     *
     * @param doubleQuery '-9999999.999'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void doubleDecimalNegativeAsync(Double doubleQuery, final ServiceCallback<Void> serviceCallback) {
        service.doubleDecimalNegativeAsync(doubleQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(doubleDecimalNegativeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> doubleDecimalNegativeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null numeric value (no query parameter)
     *
     * @param doubleQuery null numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void doubleNull(Double doubleQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = doubleNullDelegate(service.doubleNull(doubleQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = doubleNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null numeric value (no query parameter)
     *
     * @param doubleQuery null numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void doubleNullAsync(Double doubleQuery, final ServiceCallback<Void> serviceCallback) {
        service.doubleNullAsync(doubleQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(doubleNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> doubleNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
     *
     * @param stringQuery '啊齄丂狛狜隣郎隣兀﨩'multi-byte string value. Possible values for this parameter include: '啊齄丂狛狜隣郎隣兀﨩'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringUnicode(String stringQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = stringUnicodeDelegate(service.stringUnicode(stringQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringUnicodeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
     *
     * @param stringQuery '啊齄丂狛狜隣郎隣兀﨩'multi-byte string value. Possible values for this parameter include: '啊齄丂狛狜隣郎隣兀﨩'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringUnicodeAsync(String stringQuery, final ServiceCallback<Void> serviceCallback) {
        service.stringUnicodeAsync(stringQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringUnicodeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringUnicodeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end
     *
     * @param stringQuery 'begin!*'();:@ &amp;=+$,/?#[]end' url encoded string value. Possible values for this parameter include: 'begin!*'();:@ &amp;=+$,/?#[]end'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringUrlEncoded(String stringQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = stringUrlEncodedDelegate(service.stringUrlEncoded(stringQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringUrlEncodedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end
     *
     * @param stringQuery 'begin!*'();:@ &amp;=+$,/?#[]end' url encoded string value. Possible values for this parameter include: 'begin!*'();:@ &amp;=+$,/?#[]end'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringUrlEncodedAsync(String stringQuery, final ServiceCallback<Void> serviceCallback) {
        service.stringUrlEncodedAsync(stringQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringUrlEncodedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringUrlEncodedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get ''
     *
     * @param stringQuery '' string value. Possible values for this parameter include: ''
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringEmpty(String stringQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = stringEmptyDelegate(service.stringEmpty(stringQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get ''
     *
     * @param stringQuery '' string value. Possible values for this parameter include: ''
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringEmptyAsync(String stringQuery, final ServiceCallback<Void> serviceCallback) {
        service.stringEmptyAsync(stringQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null (no query parameter in url)
     *
     * @param stringQuery null string value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringNull(String stringQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = stringNullDelegate(service.stringNull(stringQuery), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null (no query parameter in url)
     *
     * @param stringQuery null string value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringNullAsync(String stringQuery, final ServiceCallback<Void> serviceCallback) {
        service.stringNullAsync(stringQuery, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get using uri with query parameter 'green color'
     *
     * @param enumQuery 'green color' enum value. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void enumValid(UriColor enumQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = enumValidDelegate(service.enumValid(JacksonHelper.serializeRaw(enumQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = enumValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get using uri with query parameter 'green color'
     *
     * @param enumQuery 'green color' enum value. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void enumValidAsync(UriColor enumQuery, final ServiceCallback<Void> serviceCallback) {
        service.enumValidAsync(JacksonHelper.serializeRaw(enumQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(enumValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> enumValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null (no query parameter in url)
     *
     * @param enumQuery null string value. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void enumNull(UriColor enumQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = enumNullDelegate(service.enumNull(JacksonHelper.serializeRaw(enumQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = enumNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null (no query parameter in url)
     *
     * @param enumQuery null string value. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void enumNullAsync(UriColor enumQuery, final ServiceCallback<Void> serviceCallback) {
        service.enumNullAsync(JacksonHelper.serializeRaw(enumQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(enumNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> enumNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteMultiByte(byte[] byteQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = byteMultiByteDelegate(service.byteMultiByte(Base64.encodeBase64String(byteQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteMultiByteDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteMultiByteAsync(byte[] byteQuery, final ServiceCallback<Void> serviceCallback) {
        service.byteMultiByteAsync(Base64.encodeBase64String(byteQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteMultiByteDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteMultiByteDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '' as byte array
     *
     * @param byteQuery '' as byte array
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteEmpty(byte[] byteQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = byteEmptyDelegate(service.byteEmpty(Base64.encodeBase64String(byteQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '' as byte array
     *
     * @param byteQuery '' as byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteEmptyAsync(byte[] byteQuery, final ServiceCallback<Void> serviceCallback) {
        service.byteEmptyAsync(Base64.encodeBase64String(byteQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as byte array (no query parameters in uri)
     *
     * @param byteQuery null as byte array (no query parameters in uri)
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteNull(byte[] byteQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = byteNullDelegate(service.byteNull(Base64.encodeBase64String(byteQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as byte array (no query parameters in uri)
     *
     * @param byteQuery null as byte array (no query parameters in uri)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteNullAsync(byte[] byteQuery, final ServiceCallback<Void> serviceCallback) {
        service.byteNullAsync(Base64.encodeBase64String(byteQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '2012-01-01' as date
     *
     * @param dateQuery '2012-01-01' as date
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateValid(LocalDate dateQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = dateValidDelegate(service.dateValid(JacksonHelper.serializeRaw(dateQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '2012-01-01' as date
     *
     * @param dateQuery '2012-01-01' as date
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateValidAsync(LocalDate dateQuery, final ServiceCallback<Void> serviceCallback) {
        service.dateValidAsync(JacksonHelper.serializeRaw(dateQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as date - this should result in no query parameters in uri
     *
     * @param dateQuery null as date (no query parameters in uri)
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateNull(LocalDate dateQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = dateNullDelegate(service.dateNull(JacksonHelper.serializeRaw(dateQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as date - this should result in no query parameters in uri
     *
     * @param dateQuery null as date (no query parameters in uri)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateNullAsync(LocalDate dateQuery, final ServiceCallback<Void> serviceCallback) {
        service.dateNullAsync(JacksonHelper.serializeRaw(dateQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time
     *
     * @param dateTimeQuery '2012-01-01T01:01:01Z' as date-time
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateTimeValid(DateTime dateTimeQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = dateTimeValidDelegate(service.dateTimeValid(JacksonHelper.serializeRaw(dateTimeQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateTimeValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time
     *
     * @param dateTimeQuery '2012-01-01T01:01:01Z' as date-time
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateTimeValidAsync(DateTime dateTimeQuery, final ServiceCallback<Void> serviceCallback) {
        service.dateTimeValidAsync(JacksonHelper.serializeRaw(dateTimeQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateTimeValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateTimeValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri
     *
     * @param dateTimeQuery null as date-time (no query parameters)
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateTimeNull(DateTime dateTimeQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = dateTimeNullDelegate(service.dateTimeNull(JacksonHelper.serializeRaw(dateTimeQuery)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateTimeNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as date-time, should result in no query parameters in uri
     *
     * @param dateTimeQuery null as date-time (no query parameters)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateTimeNullAsync(DateTime dateTimeQuery, final ServiceCallback<Void> serviceCallback) {
        service.dateTimeNullAsync(JacksonHelper.serializeRaw(dateTimeQuery), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateTimeNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateTimeNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringCsvValid(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringCsvValidDelegate(service.arrayStringCsvValid(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringCsvValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringCsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringCsvValidAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringCsvValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringCsvValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get a null array of string using the csv-array format
     *
     * @param arrayQuery a null array of string using the csv-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringCsvNull(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringCsvNullDelegate(service.arrayStringCsvNull(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringCsvNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get a null array of string using the csv-array format
     *
     * @param arrayQuery a null array of string using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringCsvNullAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringCsvNullAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringCsvNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringCsvNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an empty array [] of string using the csv-array format
     *
     * @param arrayQuery an empty array [] of string using the csv-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringCsvEmpty(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringCsvEmptyDelegate(service.arrayStringCsvEmpty(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringCsvEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an empty array [] of string using the csv-array format
     *
     * @param arrayQuery an empty array [] of string using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringCsvEmptyAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringCsvEmptyAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.CSV), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringCsvEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringCsvEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringSsvValid(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringSsvValidDelegate(service.arrayStringSsvValid(JacksonHelper.serializeList(arrayQuery, CollectionFormat.SSV)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringSsvValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringSsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringSsvValidAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.SSV), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringSsvValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringSsvValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringTsvValid(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringTsvValidDelegate(service.arrayStringTsvValid(JacksonHelper.serializeList(arrayQuery, CollectionFormat.TSV)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringTsvValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringTsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringTsvValidAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.TSV), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringTsvValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringTsvValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void arrayStringPipesValid(List<String> arrayQuery) throws ServiceException {
        try {
            ServiceResponse<Void> response = arrayStringPipesValidDelegate(service.arrayStringPipesValid(JacksonHelper.serializeList(arrayQuery, CollectionFormat.PIPES)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = arrayStringPipesValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@
     * &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void arrayStringPipesValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        service.arrayStringPipesValidAsync(JacksonHelper.serializeList(arrayQuery, CollectionFormat.PIPES), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(arrayStringPipesValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> arrayStringPipesValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

}
